# 位运算符

## 位运算符的应用

(1) 判断int型变量a是奇数还是偶数           

```
a&1   = 0 偶数
a&1 =   1 奇数
```
(2) 不用temp交换两个整数

```
void swap(int x , int y)
{
 x ^= y;
 y ^= x;
 x ^= y;
}
```

(3)取模运算转化成位运算 (在不产生溢出的情况下)

```
a % (2^n) 等价于 a & (2^n - 1)
```
(4)乘法运算转化成位运算 (在不产生溢出的情况下)

```
a * (2^n) 等价于 a<< n
```
(5)除法运算转化成位运算 (在不产生溢出的情况下)

```
a / (2^n) 等价于 a>> n
例: 12/8 == 12>>3
```

(6) a % 2 等价于 a & 1   因为一个数必然为奇数或者偶数 奇数必然含1

```
 a % 2 等价于 a & 1  ( a  & log2(2))      
 
 a % 4 等价于 a & 2  ( a  & log2(4))  

.....

 a % 32 等价于 a & 5
 
 a % 2结果分为两种0 不为0 为0即整数倍
 
 不为0即2N+K k为余数 k<必然小于2 所以已2为参考
```

(7) 整数的平均值

对于两个整数x,y，如果用 (x+y)/2 求平均值，会产生溢出，因为 x+y 可能会大于INT_MAX

int average(int x, int y)   //返回X,Y 的平均值
{   
     return (x&y)+((x^y)>>1);   //x&y x、y公共部分  x^y代表x、y特有部分 (x/y=2^0+2^1+....+2^N-1)
}

3、取相反数
也就是将正数n变为-n，将负数n变为-n。
将整数取反加1即可得到其相反数：
            例如，32位系统中正数13（二进制表示为00000000 00000000 00000000 00001101），
            取反为（11111111 11111111 11111111 11110010），
            然后再加1为（11111111 11111111  11111111 11110011），计算机中数是用二进制的补码表示的，
            因此取反加1的结果（11111111 11111111  11111111  11110011）即为-13的二进制补码表示形式。

常见的一个等式：-n = ~(n - 1) = ~n + 1