---
title: 哈希表
date: 2018-04-13 11:23:40
tags:
- 数据结构
- 算法
categories:
- 数据结构
- 算法
---

<ul>
<li><a href="#introduce">介绍</a>
<ul>
<li><a href="#hash">什么是Hash?</a></li>
</ul>
</li>
<li><a href="#compare">之前的数据结构的优缺点</a></li>
<li><a href="#hash-method">散列方式(常用hash函数构造方式)</a>
<ul>
<li><a href="#method1">除法散列法----求模数</a></li>
<li><a href="#method2">平方散列法----位运算</a></li>
<li><a href="#method3">斐波那契（Fibonacci）散列法</a></li>
<li><a href="#method4">直接寻址法</a></li>
<li><a href="#method5">数字分析法</a></li>
<li><a href="#method6">平方取中法</a></li>
<li><a href="#method7">折叠法</a></li>
</ul>
</li>
<li><a href="#conflict">碰撞处理</a>
<ul>
<li><a href="#function1">开放定址法</a></li>
<li><a href="#function2">再哈希法</a></li>
<li><a href="#function3">拉链法</a></li>
<li><a href="#function4">建立公共溢出区</a></li>
</ul>
</li>
</ul>
引用地址:
[从头到尾彻底解析哈希表算法](http://blog.jobbole.com/49229/)
[哈希表](https://note.youdao.com/web/#/file/WEBa16de4ed4bed4c6dbe14ea7698d7c626/pdf/WEB1426d0f0671aa9aa19629933d3578393/)

# Hash表

<h2 id="introduce">介绍</h2>

<h3 id="hash">什么是hash?</h3>

 &nbsp;&nbsp;&nbsp;&nbsp;Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），**通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。**

&nbsp;&nbsp;&nbsp;&nbsp;HASH主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做HASH值. 也可以说，**hash就是找到一种数据内容和数据存放地址之间的映射关系。**

<h2 id="compare">之前的数据结构的优缺点</h2>

数组的特点是：**寻址容易**，插入和删除困难；
链表的特点是：寻址困难，**插入和删除容易**;

二者结合:解决hash问题----**拉链法**，我们可以理解为“链表的数组”
![拉链法](http://jbcdn2.b0.upaiyun.com/2013/10/ctdwcdjxhxbsf01.jpg)

拉链法介绍:

&nbsp;&nbsp;&nbsp;&nbsp;左边很明显是个数组，**数组的每个成员包括一个指针，指向一个链表的头**，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。

<h2 id="hash-method">散列方式</h2>

散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。
实际工作中需视不同的情况采用不同的哈希函数，通常考虑的因素有：

    计算哈希函数所需时间
    关键字的长度
    哈希表的大小
    关键字的分布情况
    记录的查找频率

<strong><h3 id="method1">1.除法散列法----求模数</h3></strong>

最直观的一种，上图使用的就是这种散列法，公式：
index = value % 16
学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。

<strong><h3 id="method2">2.平方散列法----位运算</h3></strong>

求index是非常频繁的操作，而**乘法的运算要比除法来得省时**（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：index = (value * value) >> 28   （右移，除以2^28。记法：左移变大，是乘。右移变小，是除。）
如果数值分配比较均匀的话这种方法能得到不错的结果。但还有个问题，**value如果很大，value * value不会溢出吗？答案是会的**。

<strong><h3 id="method3">3.斐波那契（Fibonacci）散列法</h3></strong>

平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。

>1，对于16位整数而言，这个乘数是40503
2，对于32位整数而言，这个乘数是2654435769
3，对于64位整数而言，这个乘数是11400714819323198485

这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,233, 377, 610， 987, 1597, 2584, 4181, 6765, 10946，…。另外，斐波那契数列的值和太阳系八大行星的轨道半径的比例出奇吻合。

对我们常见的32位整数而言，公式：
index = (value * 2654435769) >> 28

<strong><h3 id="method4">4. 直接寻址法</h3></strong>    

&nbsp;&nbsp;&nbsp;&nbsp;**取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b**，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。

<strong><h3 id="method5">5.数字分析法</h3></strong> 

&nbsp;&nbsp;&nbsp;&nbsp;分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此**数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。**

<strong><h3 id="method6">6.平方取中法</h3></strong> 

&nbsp;&nbsp;&nbsp;&nbsp;当无法确定关键字中哪几位分布较均匀时，可以**先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。**这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址

|关键字|内部编码|内部编码的平方值|H(k)关键字的哈希地址|
|------|--------|----------------|--------------------|
|KEYA|11050201|122157778355001|778|
|KYAB|11250102|126564795010404|795|

<strong><h3 id="method7">7.折叠法</h3></strong> 

&nbsp;&nbsp;&nbsp;&nbsp;将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。

**适用范围**

&nbsp;&nbsp;&nbsp;&nbsp;**快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。**


<h2 id="conflict">碰撞处理</h2>

<strong><h3 id="function1">1.开放定址法</h3></strong>

&nbsp;&nbsp;&nbsp;&nbsp;这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：
          **Hi=（H（key）+di）% m   i=1，2，…，n
    其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。**

主要有以下三种：
**(1)线性探测再散列**
    dii=1，2，3，…，m-1
这种方法的特点是：冲突发生时，**顺序查看表中下一单元，直到找出一个空单元或查遍全表。**
**(2)二次探测再散列**
    di=12，-12，22，-22，…，k2，-k2    ( k<=m/2 )
    这种方法的特点是：冲突发生时，在表的左右进行**跳跃式探测，比较灵活。**
**(3)伪随机探测再散列**
    &nbsp;&nbsp;&nbsp;&nbsp;di=伪随机数序列。
&nbsp;&nbsp;&nbsp;&nbsp;具体实现时，应建立一个**伪随机数发生器**，（如i=(i+p)%m），并给定一个随机数做起点。
   
&nbsp;&nbsp;&nbsp;&nbsp;例如，已知哈希表长度m=11，哈希函数为：H（key）= key  %  11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。

&nbsp;&nbsp;&nbsp;&nbsp;如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。

&nbsp;&nbsp;&nbsp;&nbsp;如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。

&nbsp;&nbsp;&nbsp;&nbsp;如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。


&nbsp;&nbsp;&nbsp;&nbsp;从上述例子可以看出，**线性探测再散列容易产生“二次聚集”，即在处理同义词的冲突时又导致非同义词的冲突。**例如，当表中i, i+1 ,i+2三个单元已满时，下一个哈希地址为i, 或i+1 ,或i+2，或i+3的元素，都将填入i+3这同一个单元，而这四个元素并非同义词。**线性探测再散列的优点是：只要哈希表不满，就一定能找到一个不冲突的哈希地址，而二次探测再散列和伪随机探测再散列则不一定。**

<strong><h3 id="function2">2.再哈希法</h3></strong>

&nbsp;&nbsp;&nbsp;&nbsp;这种方法是**同时构造多个不同的哈希函数**：
    Hi=RH1（key）  i=1，2，…，k
&nbsp;&nbsp;&nbsp;&nbsp;**当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。**

<strong><h3 id="function3">3.拉链法</h3></strong>

&nbsp;&nbsp;&nbsp;&nbsp;这种方法的基本思想是**将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中**，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

**php数组,java map采用这种方式**

<strong><h3 id="function4">4.建立公共溢出区</h3></strong>

&nbsp;&nbsp;&nbsp;&nbsp;这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表