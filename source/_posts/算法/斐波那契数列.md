---
title: 斐波那契数列
date: 2018-04-13 13:37:04
tags:
- 数据结构
- 算法
categories:
- 数据结构
- 算法
---

在数学上，斐波纳契数列以如下被以递归的方法定义： 
F（0）=0，F（1）=1，F（n）=F(n-1)+F(n-2)（n≥2，n∈N*）

<ul>
<li><a href="#recursion">递归</a></li>
<li><a href="#recursion_opt">递归优化</a></li>
<li><a href="#loop">循环</a></li>
<li><a href="#compare">递归和循环比较</a></li>
</ul>

<h2 id="recursion">1.递归</h2>

    function f($a)
    {
        if ($a == 0 || $a == 1) {
            return 1;
        }
        return f($a-1) + f($a-2);
    }
    
    for($i = 0; $i < 70; ++$i)
    {
        echo f($i).' ';
    }

缺点:

&nbsp;&nbsp;&nbsp;&nbsp;递归其实是方便了程序员,难为了机器。它只要得到数学公式就能很方便的写出程序。优点就是易理解，容易编程。但**递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，对嵌套层数深的一些算法，递归会力不从心，空间上会以内存崩溃或超时而告终，而且递归也带来了大量的函数调用，这也有许多额外的时间开销。所以在深度大时，它的时空性就不好了**

<h2 id="recursion_opt">2.递归优化(使用一个全局数组，来保存之前的结果)</h2>

    function f($n, $arr)
    {
        global $arr;
        if(isset($arr[$n]) ) {  //比 array_key_exits()效率高
            return $arr[$n];
        }
        return f($n-1, $arr) + f($n-2, $arr);
    }
    $arr = [
        0 => 1,
        1 => 1,
    ];
    for($i = 0; $i < 1000000; ++$i)
    {
        $arr[$i] = f($i, $arr);
        echo f($i, $arr).' ';
    }

<h2 id="loop">3.使用循环实现</h2>

    <?php 
    $arr[1] = 1;
    for($i = 2;$i < 100;$i++)
    {
        $arr[$i] = $arr[$i-1] + $arr[$i-2];
    }
    echo join(",",$arr);  //将数组合并为一个字符串输出
    ?>

<h2 id="compare">4.递归和循环的简单比较</h2>

    1、从程序上看，递归表现为自己调用自己，循环则没有这样的形式。
    2、递归是从问题的最终目标出发，逐渐将复杂问题化为简单问题，并且简单的问题的解决思路和复杂问题一样，同时存在基准情况，就能最终求得问题，是逆向的。而循环是从简单问题出发，一步步的向前发展，最终求得问题，是正向的。
    3、任意循环都是可以用递归来表示的，但是想用循环来实现递归（除了单向递归和尾递归），都必须引入栈结构进行压栈出栈。
    4、一般来说，非递归的效率高于递归。而且递归函数调用是有开销的，递归的次数受堆栈大小的限制。

[尾递归](http://book.51cto.com/art/201212/370096.htm)